# 万里挑一

首先是脚本环节。把需求描述给AI就能拿到脚本：
```py
#谢谢你deepseek
import zipfile
import os
import shutil
import tempfile
import pyzipper
def extract_zip(zip_path, extract_to, password=None):
    """解压zip文件，支持AES加密"""
    try:
        if password:
            with pyzipper.AESZipFile(zip_path, 'r') as zip_ref:
                zip_ref.extractall(extract_to, pwd=password.encode())
                return True
        else:
            with zipfile.ZipFile(zip_path, 'r') as zip_ref:
                zip_ref.extractall(extract_to)
                return True
    except:
        return False

def find_txt_files(directory):
    """在目录中查找txt文件"""
    txt_files = []
    for root, _, files in os.walk(directory):
        for file in files:
            if file.endswith('.txt'):
                txt_files.append(os.path.join(root, file))
    return txt_files

def read_password_from_txt(txt_file):
    """从txt文件中读取密码"""
    try:
        with open(txt_file, 'r', encoding='utf-8') as f:
            content = f.read().strip()
            if content.startswith('The password is:'):
                return content.split(':')[1].strip()
    except (UnicodeDecodeError, IndexError, FileNotFoundError):
        pass
    return None

def test_lock_zip_password(password):
    """测试密码是否能解压lock.zip"""
    temp_dir = tempfile.mkdtemp()
    try:
        success = extract_zip('lock.zip', temp_dir, password)
        return success
    finally:
        shutil.rmtree(temp_dir, ignore_errors=True)

def process_zip_file(zip_path, depth=0, max_depth=100):
    """递归处理zip文件"""
    if depth > max_depth:
        return None
    
    temp_dir = tempfile.mkdtemp()
    try:
        # 解压当前zip文件
        if not extract_zip(zip_path, temp_dir):
            return None
        
        # 检查是否有txt文件
        txt_files = find_txt_files(temp_dir)
        for txt_file in txt_files:
            password = read_password_from_txt(txt_file)
            if password:
                print(f"找到潜在密码: {password}")
                if test_lock_zip_password(password):
                    print(f"成功找到lock.zip的密码: {password}")
                    return password
        
        # 如果没有找到txt文件，查找下一层的zip文件
        zip_files = []
        for root, _, files in os.walk(temp_dir):
            for file in files:
                if file.endswith('.zip'):
                    zip_files.append(os.path.join(root, file))
        
        # 递归处理每个zip文件
        for next_zip in zip_files:
            result = process_zip_file(next_zip, depth + 1, max_depth)
            if result:
                return result
        
        return None
        
    finally:
        shutil.rmtree(temp_dir, ignore_errors=True)

def main():
    # 检查文件是否存在
    if not os.path.exists('password.zip'):
        print("错误: 找不到password.zip文件")
        return
    
    if not os.path.exists('lock.zip'):
        print("错误: 找不到lock.zip文件")
        return
    
    print("开始搜索密码...")
    
    # 处理初始的password.zip
    password = process_zip_file('password.zip', max_depth=50)
    
    if password:
        print(f"\n✅ 成功找到lock.zip的密码: {password}")
    else:
        print("\n❌ 未找到正确的密码")

if __name__ == "__main__":
    main()
```
运行`7z l -slt lock.zip`会发现加密方式是`AES-256 Store`，而python自带的`zipfile`库不支持AES加密（表现在即使找到正确的密码也无法正确解压）。于是这里用[pyzipper](https://github.com/danifus/pyzipper)解压

密码是`a296a5ec1385f394e8cb`。解压后得到flag.zip，然而还是加密的。继续`7z l -slt flag.zip`，发现文件中有个`明文.exe`，且加密方式是`ZipCrypto Store`。明显是zip明文攻击的提示，拿出[bkcrack](https://github.com/kimci86/bkcrack)

参考这篇[文章](https://www.freebuf.com/articles/network/255145.html)的`3.2.4`节，从偏移64处开始的64个字节在每个exe文件里都一样。于是提取明文到`known`后运行命令：
```sh
bkcrack -C flag.zip -c "明文.exe" -p ./known -o 64
```
即可得到key。然后移除压缩包的密码：
```sh
bkcrack -C flag.zip -k eec878a3 6808e48f 3aa41bd8 -D decrypted.zip
```
就能得到flag了