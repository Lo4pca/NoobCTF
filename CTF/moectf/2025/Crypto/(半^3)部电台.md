# (半^3)部电台

做个200分的题把自己SAN值用光了……

描述提到了密码机，于是请出chatgpt分析这题是否和某个已知密码系统有关系。它说这是2轮的des。完全不知道des内部是什么结构的我遂搜索相关内容，得到 https://crypto.stackexchange.com/questions/14567/exercise-attack-on-a-two-round-des-cipher

这个资料描述的情况与这道题有一点不同：这题的F函数不是黑盒的，所以可以根据F函数内部的状态加速爆破key。资料内的这个结论非常重要：
```
𝐿1=𝑅0
𝑅1=𝐿0⊕𝐹(𝑅0,𝐾0)

𝐿2=𝑅1=𝐿0⊕𝐹(𝑅0,𝐾0)
𝑅2=𝐿1⊕𝐹(𝑅1,𝐾1)=𝐿1⊕𝐹(𝐿0⊕𝐹(𝑅0,𝐾0),𝐾1)
```
利用题目给出的一个明文-密文对，我们能得到𝐹(𝑅0,𝐾0)和𝐹(𝑅1,𝐾1)的值：
```
𝐹(𝑅0,𝐾0)=𝐿2⊕𝐿0
𝐹(𝑅1,𝐾1)=𝑅2⊕𝑅0
```
这题的F函数是从`R_expanded = `到`res_p = `的部分。接下来分析怎么利用F函数得到subkey

- F函数的输出是res_p，为res应用P排列后的结果->对res_p逆应用P得到原本的res
- res为一个32 bit字符串，每4个bit为int_res->按4个bit为一组分割res，得到int_res
- `int_res = self.S[i][16 * row + col]`->`16 * row + col=self.S[i].index(int_res)`
- 现在问题来了。查看每个S盒的构造，发现盒里的64个值实际上是16个打乱的值重复4行，意味着`16 * row + col`的值不唯一。因此需要爆破row值的四种可能，算出对应的col值
- 用row和col值能够恢复`R_groups[i]`的值
- `R_groups`异或`R_expanded`可以得到 $k_i$

上述过程只需要一块明文-密文（64bit）就能实现，得到所有可能的 $k_0,k_1$ 值。然后可以用明文-密文对剩下的部分筛选出真正的 $k_0,k_1$

看到这其实就可以了。因为我不会处理细节（而且细节也不重要，离开这题就没用了），而且我永远分不清类feistel网络的L和R，再加上我的python水平从未提升，最后我写到后面已经神志不清了；导致最后的脚本乱七八糟的，基本没有任何阅读的意义
```py
from Crypto.Util.number import *
from itertools import product
#省略8个S盒，IP，P和E表
S = [S1, S2, S3, S4, S5, S6, S7, S8]
P_inv=[P.index(i) + 1 for i in range(1, 33)]
IP_inv = [IP.index(i) + 1 for i in range(1, 65)]
def xor(a,b):
    return ''.join(str(int(a[i]) ^ int(b[i])) for i in range(len(a)))
def apply(a,table):
    return ''.join(a[i - 1] for i in table)
def inv_IP(a):
    return ''.join(a[i - 1] for i in IP_inv)
def inv_P(a):
    return ''.join(a[i - 1] for i in P_inv)
def to_bin(text):
    bin_text = ''.join([bin(byte)[2:].zfill(8) for byte in text])
    padded_len = (64 - (len(bin_text) % 64)) % 64
    return bin_text + '0' * padded_len
def split(bin_text):
    return [bin_text[i * 64:(i + 1) * 64] for i in range(0, len(bin_text) // 64)]
flag=
m=
c=
c=long_to_bytes(c)
m=long_to_bytes(m)
flag=long_to_bytes(flag)
splitted_m=split(to_bin(m))
splitted_flag=split(to_bin(flag))
split_c=split(to_bin(c))
possible_keys=[[] for _ in range(2)]
def brute(res,R_expanded,idx):
    R_groups=[[] for _ in range(8)]
    for j in range(8):
        int_res=int(res[j*4:j*4+4],2)
        for row in range(4):
            col=bin(S[j][16*row:16*row+16].index(int_res))[2:].zfill(4)
            row=bin(row)[2:].zfill(2)
            R_groups[j].append(row[0]+col+row[1])
    for comb in product(*R_groups):
        possible_keys[idx].append(xor(''.join(comb),R_expanded))
block=split_c[0]
m_block=apply(splitted_m[0],IP)
init_L, init_R = m_block[:32], m_block[32:]
c_block = apply(block,IP)
L2, R2 = c_block[32:], c_block[:32] #因为最后得到的t = R + L
brute(inv_P(xor(L2, init_L)),apply(init_R,E),0)
brute(inv_P(xor(R2, init_R)),apply(L2,E),1)
def F(R,k):
    R_expanded = ''.join(R[i - 1] for i in E)
    R_xor = [str(int(R_expanded[i]) ^ int(k[i])) for i in range(48)]
    R_groups = [R_xor[i:i + 6] for i in range(0, 48, 6)]
    res = ''
    for i in range(8):
        row = int(R_groups[i][0] + R_groups[i][5], base=2)
        col = int(''.join(R_groups[i][1:5]), base=2)
        int_res = S[i][16 * row + col]
        res += bin(int_res)[2:].zfill(4)
    return ''.join(res[i - 1] for i in P)
def brute_k1(possible_keys,L2,R2,expected_R0):
    keys=set()
    for k1 in possible_keys:
        res=xor(R2,F(L2,k1))
        if res==expected_R0 and k1 not in keys:
            keys.add(k1)
    return keys
def brute_k0(possible_keys,L2,expected_R0,expected_L0):
    keys=set()
    for k0 in possible_keys:
        res=xor(L2,F(expected_R0,k0))
        if res==expected_L0 and k0 not in keys:
            keys.add(k0)
    return keys
print("Finish gathering possible keys")
print("Finding k1 now")
keys=set(possible_keys[1])
for i in range(1,len(splitted_m)):
    test_block=apply(split_c[i],IP)
    L2,R2=test_block[32:], test_block[:32]
    candidates=brute_k1(keys,L2,R2,apply(splitted_m[i],IP)[32:])
    if len(candidates)==0:
        continue
    keys&=candidates
    if len(keys)==1:
        break
k1=keys.pop()
print(f"{k1=}")
print("Finding k0 now")
keys=set(possible_keys[0])
for i in range(1,len(splitted_m)):
    test_block=apply(split_c[i],IP)
    L2=test_block[32:]
    candidates=brute_k0(keys,L2,apply(splitted_m[i],IP)[32:],apply(splitted_m[i],IP)[:32])
    if len(candidates)==0:
        continue
    keys&=candidates
    if len(keys)==1:
        break
k0=keys.pop()
print(f"{k0=}")
def decrypt(k0,k1,block):
    block=apply(block,IP)
    L2, R2 = block[32:], block[:32]
    R0=xor(R2,F(L2,k1))
    L0=xor(L2,F(R0,k0))
    return inv_IP(L0+R0)
flag=''
for i in range(len(splitted_flag)):
    flag+=decrypt(k0,k1,splitted_flag[i])
message=long_to_bytes(int(flag,2)).decode()
print(message)
flag=''
for i in range(len(message)-1):
    if message[i+1]=='.':
        flag+=message[i]
print(flag)
```
（但是看着挺壮观的）