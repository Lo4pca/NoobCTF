# 杂交随机数

AI没法独自做出这道题了（

但是人工观察到lfsr的输出是`data[1:]+str(bit)`，即我们损失的只有data的第一个bit。很明显需要爆破，用dfs走遍0和1两个分支。拿到原始的L后便可以逆向lcg，于是上一轮的R也到手了

然而我无论如何都只能写出一个跑不了的poc，因为搞不明白L和R交换的顺序以及一堆乱七八槽的细节。于是又回到AI，它几秒不到解决困扰我几个小时的问题……
```py
from Crypto.Util.number import long_to_bytes
import sys
sys.setrecursionlimit(10000) #默认的最大递归深度不够
def lfsr(data, mask):
    mask = mask.zfill(len(data))
    res_int = int(data, 2) ^ int(mask, 2)
    bit = 0
    while res_int > 0:
        bit ^= res_int & 1
        res_int >>= 1
    return data[1:] + str(bit)
def inv_lcg(x, a, b, m):
    a_inv = pow(a, -1, m)
    return (a_inv * (x - b)) % m
b = -233
en_flag = bin(4567941593066862873653209393990031966807270114415459425382356207107640)[2:]
assert len(en_flag)%8==0 #如果en_flag的长度不是8的倍数（L_init开头的0被去掉了），用下方的方式分割会出错。本地测试时我常常死在分不好L和R（
l = len(en_flag)//2
m = 1<<l
L_init=en_flag[:l]
R_init=en_flag[l:]
rounds=2025
found = []
def dfs(depth, curr_L, curr_R):
    # curr_L, curr_R correspond to (L_after, R_after) at this reverse-step
    if depth == rounds:
        candidate = long_to_bytes(int(curr_L + curr_R, 2))
        if candidate.startswith(b"moectf"):
            print("Found:", candidate)
            found.append(candidate)
        return

    # 逆向推一步：已知 curr_L (= L_after) 和 curr_R (= R_after)
    # 枚举 prev_L 的首位 0/1
    res = curr_R  # R_after == lfsr(prev_L, prev_R)
    res_prefix = res[:-1]
    for bit in ('0', '1'):
        prev_L = bit + res_prefix           # candidate L_old (as bitstring)
        seed = int(prev_L, 2)
        # 从 curr_L = lcg(prev_R, a, seed, m) 反算 prev_R
        prev_R_int = inv_lcg(int(curr_L, 2), b, seed, m)
        prev_R = bin(prev_R_int)[2:].zfill(l)

        # 验证：lfsr(prev_L, prev_R) 应该等于 curr_R
        if lfsr(prev_L, prev_R) == curr_R:
            # 进入下一层时传递 (prev_L, prev_R) —— 注意顺序不要再 swap
            dfs(depth + 1, prev_L, prev_R)

# 启动：传入最终的 (L_after, R_after) —— 也就是 encryption 结束后的 L,R
dfs(0, L_init, R_init)

if not found:
    print("No candidate matched the prefix in the explored tree.")
#moectf{I5_1t_Stream0rBlock.?}
```